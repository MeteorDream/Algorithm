---
title: ã€LeetCodeã€965 å•å€¼äºŒå‰æ ‘
date: 2022-05-24 09:41:36
updated: 2022-05-24 10:08:08
categories:
- [LeetCode]
- [LeetCode,äºŒå‰æ ‘]
tags: [LeetCode,äºŒå‰æ ‘]
---

## é¢˜ç›®

[965. å•å€¼äºŒå‰æ ‘](https://leetcode.cn/problems/univalued-binary-tree/)

<!--more-->

å¦‚æœäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½å…·æœ‰ç›¸åŒçš„å€¼ï¼Œé‚£ä¹ˆè¯¥äºŒå‰æ ‘å°±æ˜¯_å•å€¼_äºŒå‰æ ‘ã€‚

åªæœ‰ç»™å®šçš„æ ‘æ˜¯å•å€¼äºŒå‰æ ‘æ—¶ï¼Œæ‰è¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

**ç¤ºä¾‹ 1ï¼š**

![screen-shot-2018-12-25-at-50104-pm](965_å•å€¼äºŒå‰æ ‘(ç®€å•)/20220604103323.png)

> è¾“å…¥ï¼š[1,1,1,1,1,null,1]
> è¾“å‡ºï¼štrue

**ç¤ºä¾‹ 2ï¼š**

![screen-shot-2018-12-25-at-50050-pm](965_å•å€¼äºŒå‰æ ‘(ç®€å•)/20220604103347.png)

> è¾“å…¥ï¼š[2,2,2,5,2]
> è¾“å‡ºï¼šfalse

**æç¤ºï¼š**

- ç»™å®šæ ‘çš„èŠ‚ç‚¹æ•°èŒƒå›´æ˜¯ `[1, 100]`ã€‚
- æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯æ•´æ•°ï¼ŒèŒƒå›´ä¸º `[0, 99]` ã€‚

---

## é¢˜è§£

[ã€å•å€¼äºŒå‰æ ‘ã€‘ç®€å•é€»è¾‘åˆ¤æ–­](https://leetcode.cn/problems/univalued-binary-tree/solution/by-meteordream-vqvq/)

## é€’å½’

ç®€å•æ¥è¯´ï¼š

- å¦‚æœæœ‰å·¦å­æ ‘ï¼Œæ ¹ç»“ç‚¹å’Œå·¦å­©å­ç»“ç‚¹å€¼è¦ç›¸åŒï¼Œä¸”å·¦å­æ ‘æ˜¯å•å€¼äºŒå‰æ ‘
- å¦‚æœæœ‰å³å­æ ‘ï¼Œæ ¹ç»“ç‚¹å’Œå³å­©å­ç»“ç‚¹å€¼è¦ç›¸åŒï¼Œä¸”å³å­æ ‘æ˜¯å•å€¼äºŒå‰æ ‘

å¾ˆç®€å•çš„é€»è¾‘åˆ¤æ–­

```Python
# Code language: Python
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if root:
            if root.left and (root.left.val != root.val or not self.isUnivalTree(root.left)):
                return False
            if root.right and (root.right.val != root.val or not self.isUnivalTree(root.right)):
                return False
        return True
```

```Java
// Code language: Java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if (root != null) {
            if (root.left != null && (root.left.val != root.val || !isUnivalTree(root.left)))
                return false;
            if (root.right != null && (root.right.val != root.val || !isUnivalTree(root.right)))
                return false;
        }
        return true;
    }
}
```

```Cpp
// Code language: Cpp
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        if (root != nullptr) {
            if (root->left != nullptr && (root->left->val != root->val || !isUnivalTree(root->left)))
                return false;
            if (root->right != nullptr && (root->right->val != root->val || !isUnivalTree(root->right)))
                return false;
        }
        return true;
    }
};
```

å¯ä»¥å‹ç¼©åˆ°ä¸€è¡ŒğŸ¤£ğŸ¤£

```Python
# Code language: Python
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        return not root or (not (root.left and (root.left.val != root.val or not self.isUnivalTree(root.left))) and not (root.right and (root.right.val != root.val or not self.isUnivalTree(root.right))))
```

```Java
// Code language: Java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        return root == null || (!(root.left != null && (root.left.val != root.val || !isUnivalTree(root.left))) && !(root.right != null && (root.right.val != root.val || !isUnivalTree(root.right))));
    }
}
```

```Cpp
// Code language: Cpp
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        return root == nullptr || (!(root->left != nullptr && (root->left->val != root->val || !isUnivalTree(root->left))) && !(root->right != nullptr && (root->right->val != root->val || !isUnivalTree(root->right))));
    }
};
```

- æ—¶é—´å¤æ‚åº¦: $O(n)$, $n$ è¡¨ç¤ºäºŒå‰æ ‘ç»“ç‚¹æ•°é‡
- ç©ºé—´å¤æ‚åº¦: $O(1)$ï¼Œå¿½ç•¥é€’å½’å¼€é”€

---

## è¿­ä»£

ä»¥ä»»æ„å¸¸è§„æˆ–éå¸¸è§„çš„é¡ºåºéå†ä¸€éäºŒå‰æ ‘å³å¯åˆ¤æ–­

```Python
# Code language: Python
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        st = [root]
        val = root.val
        while st:
            cur = st.pop()
            if not cur.val == val:
                return False
            if cur.left: st.append(cur.left)
            if cur.right: st.append(cur.right)
        return True
```

```Java
// Code language: Java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        Deque<TreeNode> st = new ArrayDeque<>();
        if (root == null) return true;
        st.addLast(root);
        int val = root.val;
        while (!st.isEmpty()) {
            TreeNode cur = st.pollLast();
            if (cur.val != val) return false;
            if (cur.left != null) st.addLast(cur.left);
            if (cur.right != null) st.addFirst(cur.right);
        }
        return true;
    }
}
```

```Cpp
// Code language: Cpp
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        vector<TreeNode*> st;
        if (root == nullptr) return true;
        st.emplace_back(root);
        int val = root->val;
        while (!st.empty()) {
            TreeNode* cur = st.back();
            st.pop_back();
            if (cur->val != val) return false;
            if (cur->left != nullptr) st.emplace_back(cur->left);
            if (cur->right != nullptr) st.emplace_back(cur->right);
        }
        return true;
    }
};
```

- æ—¶é—´å¤æ‚åº¦: $O(n)$, $n$ è¡¨ç¤ºäºŒå‰æ ‘ç»“ç‚¹æ•°é‡
- ç©ºé—´å¤æ‚åº¦: $O(n)$
